section .text
global _fdcttest
global _idcttest


_fdcttest:
; EAX,				ECX,					EDX,				EBX,				ESP,				EBP,				ESI,				EDI,					R8D		
; AX (Accumulator)	CX (Count Register),	DX (Data Register),	BX (Base Register),	SP (Stack Pointer),	BP (Base Pointer),	SI (Source Index),	DI (Destination Index),	R8W — R15W — 16-битные
; AH, AL,			CH,	CL,					DH,	DL,				BH, BL,				SPL,				BPL,				SIL,				DIL,					R8B — R15B 

; eax = 1-й параметр и b в matrix_mul
; ecx - ch cl  - счётчики (первый для прохода по строке a (первые 4 эл, вторые 4 эл), второй для прохода по всей матрице ( 1 - 8 строки))
; edx - 2-й параметр и c в matrix_mul
; ebx - a в matrix_mul
; esp - входные параметры
; ebp
; esi - si - для проверки нужно ли умножить на 0,125
; edi
	mov eax, [esp + 4]			; 1-й параметр	
	mov edx, [esp + 8]			; 2-й параметр
	mov ebx, m_1
	

	f_mul8_start:			; деление на 8
		mulps xmm3, [del8]
		mulps xmm4, [del8]
		cmp si, 1h
		je f_mul8_end


	; умножение матриц, C = A*B
	; a = ebx
	; b = eax
	; c = edx
	xor si, si	
f_matrix_mul:		
	xor cl, cl			; обнуляем счётчик\ cl - счётчик строкиc	
	f_start:	
	
		pxor xmm3, xmm3
		pxor xmm4, xmm4
		xor ch, ch
		f_mul_start:		
		;---------------
		movups xmm0, [ebx]		; получили 1й эллемент 	
		pshufd xmm0, xmm0, 0x00

		movups xmm1, [eax]		; получаем первую строку из b
		movups xmm2, [eax+16]

		mulps xmm1, xmm0	; умножаем 
		mulps xmm2, xmm0	; получаем ряды типа (a1*b1, a1*b2, a1*b3, a1*b4)

		addps xmm3, xmm1		; тут храним результат, в конечном итоге в xmm3 и xmm4 будет строка c1 c2 c3 c4 c5 c6 c7 c8
		addps xmm4, xmm2
		;----------------
		movups xmm0, [ebx]		; получили 2й эллемент 	
		pshufd xmm0, xmm0, 0x55

		add eax, 32
		movups xmm1, [eax]		; получаем вторую строку из b
		movups xmm2, [eax+16]

		mulps xmm1, xmm0	; умножаем 
		mulps xmm2, xmm0	; получаем ряды типа (a1*b1, a1*b2, a1*b3, a1*b4)

		addps xmm3, xmm1	; суммиируем результат с предыдущим
		addps xmm4, xmm2

		;----------------
		movups xmm0, [ebx]		; получили 3й эллемент 	
		pshufd xmm0, xmm0, 0xAA

		add eax, 32
		movups xmm1, [eax]		; получаем вторую строку из b
		movups xmm2, [eax+16]

		mulps xmm1, xmm0	; умножаем 
		mulps xmm2, xmm0	; получаем ряды типа (a1*b1, a1*b2, a1*b3, a1*b4)

		addps xmm3, xmm1	; суммиируем результат с предыдущим
		addps xmm4, xmm2
		;----------------
		movups xmm0, [ebx]		; получили 4й эллемент 	
		pshufd xmm0, xmm0, 0xFF

		add eax, 32
		movups xmm1, [eax]		; получаем вторую строку из b
		movups xmm2, [eax+16]

		mulps xmm1, xmm0	; умножаем 
		mulps xmm2, xmm0	; получаем ряды типа (a1*b1, a1*b2, a1*b3, a1*b4)

		addps xmm3, xmm1	; суммиируем результат с предыдущим
		addps xmm4, xmm2
		;----------------		
		cmp ch, 1h		;	переходим на ret если прошли по всей строке
		je f_mul_end
		inc ch			; увеличили счётчик	
		add ebx, 16
		add eax, 32
		jmp f_mul_start	
	
	f_mul_end:			
		; в этот момент у нас записаны в xmm3 и xmm4 строка c1 c2 c3 c4 c5 c6 c7 c8				
		sub eax, 224	; возвращаемся в начало матрицы b
		sub ebx, 16		; возвращаем ebx в начало строки

		cmp si, 1h
		je f_mul8_start		;делим на 8 регистры xmm3, xmm4, но только если si=1, т.е. мы уже умножили матрицы между собой 

		f_mul8_end:

		movups [edx], xmm3			; записываем первые 4
		movups [edx+16], xmm4		; записываем вторые 4			

		cmp cl, 7h		;	переходим на ret если прошли по всей матрице
		je f_return
		inc cl			; увеличили счётчик		
		add edx, 32
		add ebx, 32
		jmp f_start		; переходим на следующую строку

	f_return: 

	sub edx, 224


	cmp si, 1h
	je f_end_mul
	inc si
	mov eax, m_2		; b = m2
	mov ebx, edx		; a = edx
	jmp f_matrix_mul

	f_end_mul:

	ret

; -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_idcttest:
	mov eax, [esp + 4]			; 1-й параметр	
	mov edx, [esp + 8]			; 2-й параметр
	mov ebx, m_2


	pxor xmm3, xmm3
	pxor xmm4, xmm4
	i_mul8_start:			; деление на 8
		mulps xmm3, [mul8]
		mulps xmm4, [mul8]
		cmp si, 1h
		je i_mul8_end

	xor si, si
	
i_matrix_mul:		
	xor cl, cl			; обнуляем счётчик\ cl - счётчик строкиc	
	i_start:	
	
		pxor xmm3, xmm3
		pxor xmm4, xmm4
		xor ch, ch
		i_mul_start:		
		;---------------
		movups xmm0, [ebx]		; получили 1й эллемент 	
		pshufd xmm0, xmm0, 0x00

		movups xmm1, [eax]		; получаем первую строку из b
		movups xmm2, [eax+16]

		mulps xmm1, xmm0	; умножаем 
		mulps xmm2, xmm0	; получаем ряды типа (a1*b1, a1*b2, a1*b3, a1*b4)

		addps xmm3, xmm1		; тут храним результат, в конечном итоге в xmm3 и xmm4 будет строка c1 c2 c3 c4 c5 c6 c7 c8
		addps xmm4, xmm2
		;----------------
		movups xmm0, [ebx]		; получили 2й эллемент 	
		pshufd xmm0, xmm0, 0x55

		add eax, 32
		movups xmm1, [eax]		; получаем вторую строку из b
		movups xmm2, [eax+16]

		mulps xmm1, xmm0	; умножаем 
		mulps xmm2, xmm0	; получаем ряды типа (a1*b1, a1*b2, a1*b3, a1*b4)

		addps xmm3, xmm1	; суммиируем результат с предыдущим
		addps xmm4, xmm2

		;----------------
		movups xmm0, [ebx]		; получили 3й эллемент 	
		pshufd xmm0, xmm0, 0xAA

		add eax, 32
		movups xmm1, [eax]		; получаем вторую строку из b
		movups xmm2, [eax+16]

		mulps xmm1, xmm0	; умножаем 
		mulps xmm2, xmm0	; получаем ряды типа (a1*b1, a1*b2, a1*b3, a1*b4)

		addps xmm3, xmm1	; суммиируем результат с предыдущим
		addps xmm4, xmm2
		;----------------
		movups xmm0, [ebx]		; получили 4й эллемент 	
		pshufd xmm0, xmm0, 0xFF

		add eax, 32
		movups xmm1, [eax]		; получаем вторую строку из b
		movups xmm2, [eax+16]

		mulps xmm1, xmm0	; умножаем 
		mulps xmm2, xmm0	; получаем ряды типа (a1*b1, a1*b2, a1*b3, a1*b4)

		addps xmm3, xmm1	; суммиируем результат с предыдущим
		addps xmm4, xmm2
		;----------------		
		cmp ch, 1h		;	переходим на ret если прошли по всей строке
		je i_mul_end
		inc ch			; увеличили счётчик	
		add ebx, 16
		add eax, 32
		jmp i_mul_start	
	
	i_mul_end:			
		; в этот момент у нас записаны в xmm3 и xmm4 строка c1 c2 c3 c4 c5 c6 c7 c8				
		sub eax, 224	; возвращаемся в начало матрицы b
		sub ebx, 16		; возвращаем ebx в начало строки

		cmp si, 1h
		je i_mul8_start		;делим на 8 регистры xmm3, xmm4, но только если si=1, т.е. мы уже умножили матрицы между собой 

		i_mul8_end:

		movups [edx], xmm3			; записываем первые 4
		movups [edx+16], xmm4		; записываем вторые 4			

		cmp cl, 7h		;	переходим на ret если прошли по всей матрице
		je i_return
		inc cl			; увеличили счётчик		
		add edx, 32
		add ebx, 32
		jmp i_start		; переходим на следующую строку

	i_return: 

	sub edx, 224


	cmp si, 1h
	je i_end_mul
	inc si
	mov eax, m_1		; b = m2
	mov ebx, edx		; a = edx
	jmp i_matrix_mul
	i_end_mul:
	ret
	
section .data
align 16
del8: dd 0.125, 0.125, 0.125, 0.125
mul8: dd 8.000, 8.000, 8.000, 8.000
m_1: dd \
 0.35355339059327379, 0.35355339059327379, 0.35355339059327379, 0.35355339059327379,\
 0.35355339059327379, 0.35355339059327379, 0.35355339059327379, 0.35355339059327379,\
 0.49039264020161522, 0.41573480615127262, 0.27778511650980114, 0.09754516100806417,\
-0.09754516100806410,-0.27778511650980098,-0.41573480615127267,-0.49039264020161522,\
 0.46193976625564337, 0.19134171618254492,-0.19134171618254486,-0.46193976625564337,\
-0.46193976625564342,-0.19134171618254517, 0.19134171618254500, 0.46193976625564326,\
 0.41573480615127262,-0.09754516100806410,-0.49039264020161522,-0.27778511650980109,\
 0.27778511650980092, 0.49039264020161522, 0.09754516100806439,-0.41573480615127256,\
 0.35355339059327379,-0.35355339059327373,-0.35355339059327384, 0.35355339059327368,\
 0.35355339059327384,-0.35355339059327334,-0.35355339059327356, 0.35355339059327329,\
 0.27778511650980114,-0.49039264020161522, 0.09754516100806415, 0.41573480615127273,\
-0.41573480615127256,-0.09754516100806401, 0.49039264020161533,-0.27778511650980076,\
 0.19134171618254492,-0.46193976625564342, 0.46193976625564326,-0.19134171618254495,\
-0.19134171618254528, 0.46193976625564337,-0.46193976625564320, 0.19134171618254478,\
 0.09754516100806417,-0.27778511650980109, 0.41573480615127273,-0.49039264020161533,\
 0.49039264020161522,-0.41573480615127251, 0.27778511650980076,-0.09754516100806429 
m_2: dd \
 0.35355339059327379, 0.49039264020161522, 0.46193976625564337, 0.41573480615127262,\
 0.35355339059327379, 0.27778511650980114, 0.19134171618254492, 0.09754516100806417,\
 0.35355339059327379, 0.41573480615127262, 0.19134171618254492,-0.09754516100806410,\
-0.35355339059327373,-0.49039264020161522,-0.46193976625564342,-0.27778511650980109,\
 0.35355339059327379, 0.27778511650980114,-0.19134171618254486,-0.49039264020161522,\
-0.35355339059327384, 0.09754516100806415, 0.46193976625564326, 0.41573480615127273,\
 0.35355339059327379, 0.09754516100806417,-0.46193976625564337,-0.27778511650980109,\
 0.35355339059327368, 0.41573480615127273,-0.19134171618254495,-0.49039264020161533,\
 0.35355339059327379,-0.09754516100806410,-0.46193976625564342, 0.27778511650980092,\
 0.35355339059327384,-0.41573480615127256,-0.19134171618254528, 0.49039264020161522,\
 0.35355339059327379,-0.27778511650980098,-0.19134171618254517, 0.49039264020161522,\
-0.35355339059327334,-0.09754516100806401, 0.46193976625564337,-0.41573480615127251,\
 0.35355339059327379,-0.41573480615127267, 0.19134171618254500, 0.09754516100806439,\
-0.35355339059327356, 0.49039264020161533,-0.46193976625564320, 0.27778511650980076,\
 0.35355339059327379,-0.49039264020161522, 0.46193976625564326,-0.41573480615127256,\
 0.35355339059327329,-0.27778511650980076, 0.19134171618254478,-0.09754516100806429

 end